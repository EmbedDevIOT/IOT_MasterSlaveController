// #warning // analog Button
// - buttons function --
// void btn1Click();
// void btn2Click();
// void btn3Click();
// void btn3Hold();
// void btn4Click();
// void btn5Click();
// void configure();

// AnalogButtons analogButtons(KBD_PIN, INPUT, 5, 150);

// Button b1 = Button(bt1, &btn1Click);
// Button b2 = Button(bt2, &btn2Click);
// Button b3 = Button(bt3, &btn3Click, &btn3Hold, 10000, 500);
// // Button b3 = Button(bt3, &btn3Click);
// Button b4 = Button(bt4, &btn4Click);
// // get it activated (hold function invoked) only every 500ms
// // Button b4 = Button(929, &b4Click, &b4Hold, 1000, 500);
// Button b5 = Button(bt5, &btn5Click);


    #warning // analog Button
    // analogButtons.add(b1);
    // analogButtons.add(b2);
    // analogButtons.add(b3);
    // analogButtons.add(b4);
    // analogButtons.add(b5);

// Button Read
// analogButtons.check();

//=================== Keyboard buttons Handler =============================
// // Button 1 Handling (+)
// void btn1Click()
// {
//     if (menu == IDLE)
//     {
//         int hour = Clock.hour;
//         hour++;
//         if (hour > 23)
//             hour = 0;
//         Clock.hour = hour;
//         RTC.setTime(Clock);
//         Serial.printf("Hour: %d \n\r", Clock.hour);
//         Send_GPSdata();
//     }
// }
// // Button 2 Handling (-)
// void btn2Click()
// {
//     int min, hour, data, month, year;
//     STATE.menu_tmr = 0; // timer menu reset

//     switch (menu)
//     {
//     case IDLE:
//         // CarNUM (--) to IDLE state (no change TOP zone)
//         if (!UserText.hide_t)
//         {
//             UserText.carnum > 0 ? UserText.carnum-- : UserText.carnum = 99;
//             Serial.printf("CARNUM: %d \r\n", UserText.carnum);
//             SaveConfig();
//             Send_BSdata();
//         }
//         break;
//     // CarNUM (--) to General MENU  (change TOP zone)
//     case _CAR_NUM:
//         UserText.carnum > 0 ? UserText.carnum-- : UserText.carnum = 99;
//         Serial.printf("CARNUM: %d \r\n", UserText.carnum);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", UserText.carnum);
//         Send_BS_UserData(name_1, name_2);
//         SaveConfig();
//         break;
//     // GMT --
//     case _GMT:
//         if (CFG.gmt > -12 && CFG.gmt <= 12)
//         {
//             CFG.gmt--;
//             memset(name_2, 0, 15);
//             if (CFG.gmt > 0)
//             {
//                 sprintf(name_2, "+%d", CFG.gmt);
//             }
//             else
//                 sprintf(name_2, "%d", CFG.gmt);
//             Send_BS_UserData(name_1, name_2);
//         }
//         SaveConfig();
//         Serial.printf("GMT: %d \r\n", CFG.gmt);
//         break;
//     // MIN --
//     case _MIN:
//         min = Clock.minute;
//         min--;
//         if (min < 0)
//             min = 59;
//         Clock.minute = min;
//         Serial.printf("MIN: %d \r\n", min);
//         RTC.setTime(Clock);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", min);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Hour --
//     case _HOUR:
//         hour = Clock.hour;
//         hour--;
//         if (hour < 0)
//             hour = 23;
//         Clock.hour = hour;
//         RTC.setTime(Clock);
//         Serial.printf("Hour: %d \n\r", Clock.hour);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", hour);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Day --
//     case _DAY:
//         data = Clock.date;
//         month = Clock.month;
//         data--;
//         data = constrain(data, 0, DS_dim(month - 1));

//         if (data < 1)
//             data = DS_dim(month - 1);

//         Clock.date = data;
//         RTC.setTime(Clock);
//         Serial.printf("DATA: %d \t MONTH: %d \r\n ", Clock.date, Clock.month);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", Clock.date);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // MONTH --
//     case _MONTH:
//         month = Clock.month;
//         month--;
//         if (month < 1)
//         {
//             month = 12;
//         }
//         Clock.month = month;
//         RTC.setTime(Clock);
//         Serial.printf("DATA: %d \t MONTH: %d \r\n ", Clock.date, Clock.month);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", month);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Year --
//     case _YEAR:
//         year = Clock.year;
//         if (year > 2000 && year <= 2099)
//             year--;
//         Clock.year = year;
//         RTC.setTime(Clock);
//         Serial.printf("Year: %d\r\n ", Clock.year);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", Clock.year);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Brightness --
//     case _BRIGHT:

//         if (HCONF.bright > 10 && HCONF.bright <= 100)
//             HCONF.bright -= 10;

//         Serial.printf("Bright: %d\r\n ", HCONF.bright);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", HCONF.bright);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // WC Signal State Logiq
//     case _WCL:
//         (HCONF.WCL > 0 && HCONF.WCL <= 2) ? HCONF.WCL -= 1 : HCONF.WCL = 2;
//         Serial.printf("WCL: %d\r\n ", HCONF.WCL);

//         memset(name_2, 0, 15);

//         switch (HCONF.WCL)
//         {
//         case NORMAL:
//             sprintf(name_2, "Нормальн");
//             break;
//         case REVERSE:
//             sprintf(name_2, "Реверс");
//             break;
//         case ONE_HALL:
//             sprintf(name_2, "1 Тамбур");
//             break;
//         default:
//             break;
//         }
//         SaveConfig();
//         Send_BS_UserData(name_1, name_2);
//         break;

//     // WC Signal sensor state Preset
//     case _WCSS:
//         memset(name_2, 0, 25);
//         if (HCONF.WCSS == SENSOR_OPEN)
//         {
//             HCONF.WCSS = SENSOR_CLOSE;
//             sprintf(name_2, "Замкнут");
//         }
//         else
//         {
//             HCONF.WCSS = SENSOR_OPEN;
//             sprintf(name_2, "Разомкнут");
//         }
//         SaveConfig();
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // WiFI ON / OFF
//     case _WiFi:
//         if (STATE.WiFiEnable)
//         {
//             STATE.WiFiEnable = false;
//             Serial.println("WiFi_Disable");
//             memset(name_2, 0, 15);
//             sprintf(name_2, "ОТКЛ");
//             Send_BS_UserData(name_1, name_2);
//             WiFi.disconnect(true);
//             WiFi.mode(WIFI_OFF);
//         }
//         else
//         {
//             STATE.WiFiEnable = true;
//             Serial.println("WiFi_Enable");
//             memset(name_2, 0, 15);
//             sprintf(name_2, "ВКЛ");
//             Send_BS_UserData(name_1, name_2);
//             WIFIinit(AccessPoint);
//             vTaskDelay(500 / portTICK_PERIOD_MS);
//             HTTPinit(); // HTTP server initialisation
//         }
//         SaveConfig();
//         break;
//     default:
//         break;
//     }
// }
// // Button 3 Handling (Check and Select level menu)
// void btn3Click()
// {
//     STATE.menu_tmr = 0; // timer menu reset
//     menu += 1;

//     if (menu <= 11)
//     {
//         STATE.DUPDBlock = true;
//     }
//     else
//     {
//         menu = IDLE;
//         STATE.DUPDBlock = false;
//     }

//     switch (menu)
//     {
//     // CarNUM (--) to General MENU  (change TOP zone)
//     case _CAR_NUM:
//         Serial.printf("CARNUM:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Вагон:");
//         sprintf(name_2, "%d", UserText.carnum);
//         Send_BS_UserData(name_1, name_2);
//         break;
//         // Min --
//     case _GMT:
//         Serial.printf("GMT:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Час.пояс:");
//         if (CFG.gmt > 0)
//         {
//             sprintf(name_2, "+%d", CFG.gmt);
//         }
//         else
//         {
//             sprintf(name_2, "%d", CFG.gmt);
//         }
//         Send_BS_UserData(name_1, name_2);
//         break;
//     case _MIN:
//         Serial.printf("Minute:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Минута:");
//         sprintf(name_2, "%02d", Clock.minute);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // Hour --
//     case _HOUR:
//         Serial.printf("Hour:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Час:");
//         sprintf(name_2, "%02d", Clock.hour);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // Day --
//     case _DAY:
//         Serial.printf("Day:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "День:");
//         sprintf(name_2, "%d", Clock.date);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // MONTH --
//     case _MONTH:
//         Serial.printf("Month:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Месяц:");
//         sprintf(name_2, "%d", Clock.month);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // Year --
//     case _YEAR:
//         Serial.printf("Year:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Год:");
//         sprintf(name_2, "%d", Clock.year);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // Brightness --
//     case _BRIGHT:
//         old_bright = HCONF.bright;
//         Serial.printf("Brightness:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "Яркость:");
//         sprintf(name_2, "%02d", HCONF.bright);
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // WC Signal State Logiq
//     case _WCL:
//         // Saving if NEW_BRIGHT != OLD
//         if (old_bright != HCONF.bright)
//         {
//             SaveConfig();
//             Serial.printf("Saving Brightness:\r\n");
//             memset(name_1, 0, 25);
//             memset(name_2, 0, 25);
//             strcat(name_1, "Ожидайте");
//             strcat(name_2, "...");
//             Send_BS_UserData(name_1, name_2);

//             vTaskDelay(1000 / portTICK_PERIOD_MS);
//             STATE.StaticUPD = true;
//             vTaskDelay(4000 / portTICK_PERIOD_MS);
//         }

//         Serial.printf("WC Signal Logiq:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "РасполWC");
//         if (HCONF.WCL == NORMAL)
//         {
//             sprintf(name_2, "Нормальн");
//         }
//         else if (HCONF.WCL == REVERSE)
//         {
//             sprintf(name_2, "Реверс");
//         }
//         else if (HCONF.WCL == ONE_HALL)
//         {
//             sprintf(name_2, "1 Тамбур");
//         }
//         Send_BS_UserData(name_1, name_2);
//         break;

//     // WC Signal sensor state Preset
//     case _WCSS:
//         Serial.printf("WC Signal sensor preset:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "СигналWC");
//         if (HCONF.WCSS == SENSOR_OPEN)
//         {
//             sprintf(name_2, "Разомкнут");
//         }
//         else
//         {
//             sprintf(name_2, "Замкнут");
//         }
//         Send_BS_UserData(name_1, name_2);
//         break;
//     // WiFI ON / OFF
//     case _WiFi:
//         Serial.printf("WiFI Conrol:\r\n");
//         memset(name_1, 0, 25);
//         memset(name_2, 0, 25);
//         strcat(name_1, "WiFi:");
//         if (STATE.WiFiEnable)
//         {
//             sprintf(name_2, "ВКЛ");
//         }
//         else
//             sprintf(name_2, "ОТКЛ");
//         Send_BS_UserData(name_1, name_2);
//         break;
//     default:
//         break;
//     }
// }
// // Button 3 Hold Handling (Reset to default)
// void btn3Hold()
// {
//     Serial.print("button 3 hold");

//     // if (menu == IDLE)
//     // {
//     uint32_t now;
//     uint8_t cnt = 3;

//     memset(name_1, 0, 25);
//     memset(name_2, 0, 25);

//     STATE.DUPDBlock = true;
//     strcat(name_1, "Cброс");
//     itoa(cnt, name_2 + strlen(name_2), DEC);
//     Send_BS_UserData(name_1, name_2);

//     now = millis();
//     while (millis() - now < 3500)
//     {
//         vTaskDelay(1000 / portTICK_PERIOD_MS);
//         if (cnt != 0)
//         {
//             cnt--;
//             memset(name_2, 0, 25);
//             itoa(cnt, name_2 + strlen(name_2), DEC);
//             Send_BS_UserData(name_1, name_2);
//         }
//     }
//     Serial.println("#### FACTORY RESET ####");
//     memset(name_1, 0, 25);
//     memset(name_2, 0, 25);
//     strcat(name_1, "Сброшено");
//     Send_BS_UserData(name_1, name_2);
//     SystemFactoryReset();
//     SaveConfig();
//     vTaskDelay(1000 / portTICK_PERIOD_MS);
//     Serial.println("#### SAVE DONE ####");
//     ESP.restart();
//     // }
// }
// // Button 4 Handling (+)
// void btn4Click()
// {
//     int min, hour, data, month, year;

//     STATE.menu_tmr = 0; // timer menu reset

//     switch (menu)
//     {
//     case IDLE:
//         // CarNUM (++) to IDLE state (no change TOP zone)
//         if (!UserText.hide_t)
//         {
//             UserText.carnum < 99 ? UserText.carnum++ : UserText.carnum = 0;
//             Serial.printf("CARNUM: %d \r\n", UserText.carnum);
//             SaveConfig();
//             Send_BSdata();
//         }
//         break;
//     // CarNUM (++) to General MENU  (change TOP zone)
//     case _CAR_NUM:
//         UserText.carnum < 99 ? UserText.carnum++ : UserText.carnum = 0;
//         Serial.printf("CARNUM: %d \r\n", UserText.carnum);
//         memset(name_2, 0, 25);
//         sprintf(name_2, "%d", UserText.carnum);
//         Send_BS_UserData(name_1, name_2);
//         SaveConfig();
//         break;
//     // GMT ++
//     case _GMT:
//         if (CFG.gmt >= -12 && CFG.gmt < 12)
//         {
//             CFG.gmt++;
//             memset(name_2, 0, 15);
//             if (CFG.gmt > 0)
//             {
//                 sprintf(name_2, "+%d", CFG.gmt);
//             }
//             else
//                 sprintf(name_2, "%d", CFG.gmt);
//             Send_BS_UserData(name_1, name_2);
//         }
//         Serial.printf("GMT: %d \r\n", CFG.gmt);
//         SaveConfig();
//         break;
//     // MIN ++
//     case _MIN:
//         min = Clock.minute;
//         min++;
//         if (min > 59)
//             min = 0;
//         Clock.minute = min;
//         Serial.printf("MIN: %d \r\n", min);
//         RTC.setTime(Clock);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", min);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Hour ++
//     case _HOUR:
//         hour = Clock.hour;
//         hour++;
//         if (hour > 23)
//             hour = 0;
//         Clock.hour = hour;
//         RTC.setTime(Clock);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", hour);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Serial.printf("Hour: %d \n\r", Clock.hour);
//         Send_GPSdata();
//         break;
//     // Day ++
//     case _DAY:
//         data = Clock.date;
//         month = Clock.month;

//         data++;

//         if (data > constrain(data, 0, DS_dim(month - 1)))
//             data = 1;

//         Clock.date = data;
//         RTC.setTime(Clock);
//         Serial.printf("DATA: %d \t MONTH: %d \r\n ", Clock.date, Clock.month);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", Clock.date);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // MONTH ++
//     case _MONTH:
//         month = Clock.month;
//         month++;
//         if (month > 12)
//         {
//             month = 1;
//         }
//         Clock.month = month;
//         RTC.setTime(Clock);
//         Serial.printf("DATA: %d \t MONTH: %d \r\n ", Clock.date, Clock.month);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", month);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;
//     // Year ++
//     case _YEAR:
//         year = Clock.year;
//         if (year >= 2000 && year < 2099)
//         {
//             year++;
//         }
//         Clock.year = year;
//         RTC.setTime(Clock);
//         Serial.printf("Year: %d\r\n", Clock.year);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", Clock.year);
//         Send_BS_UserData(name_1, name_2);
//         vTaskDelay(100 / portTICK_PERIOD_MS);
//         Send_GPSdata();
//         break;

//     // Brightness ++
//     case _BRIGHT:
//         if (HCONF.bright >= 10 && HCONF.bright < 100)
//         {
//             HCONF.bright += 10;
//         }
//         Serial.printf("Bright: %d\r\n ", HCONF.bright);
//         memset(name_2, 0, 15);
//         sprintf(name_2, "%d", HCONF.bright);
//         Send_BS_UserData(name_1, name_2);
//         break;

//     // WC Signal State Logiq
//     case _WCL:
//         (HCONF.WCL >= 0 && HCONF.WCL < 2) ? HCONF.WCL += 1 : HCONF.WCL = 0;
//         Serial.printf("WCL: %d\r\n ", HCONF.WCL);
//         memset(name_2, 0, 15);
//         switch (HCONF.WCL)
//         {
//         case NORMAL:
//             sprintf(name_2, "Нормальн");
//             break;
//         case REVERSE:
//             sprintf(name_2, "Реверс");
//             break;
//         case ONE_HALL:
//             sprintf(name_2, "1 Тамбур");
//             break;
//         default:
//             break;
//         }
//         SaveConfig();
//         Send_BS_UserData(name_1, name_2);
//         break;

//     // WC Signal sensor state Preset
//     case _WCSS:
//         memset(name_2, 0, 25);
//         if (HCONF.WCSS == SENSOR_OPEN)
//         {
//             HCONF.WCSS = SENSOR_CLOSE;
//             sprintf(name_2, "Замкнут");
//         }
//         else
//         {
//             HCONF.WCSS = SENSOR_OPEN;
//             sprintf(name_2, "Разомкнут");
//         }
//         SaveConfig();
//         Send_BS_UserData(name_1, name_2);
//         break;

//     // WiFI ON / OFF
//     case _WiFi:

//         if (STATE.WiFiEnable)
//         {
//             STATE.WiFiEnable = false;
//             Serial.println("WiFi_Disable");
//             memset(name_2, 0, 15);
//             sprintf(name_2, "ОТКЛ");
//             Send_BS_UserData(name_1, name_2);
//             WiFi.disconnect(true);
//             WiFi.mode(WIFI_OFF);
//         }
//         else
//         {
//             STATE.WiFiEnable = true;
//             Serial.println("WiFi_Enable");
//             memset(name_2, 0, 15);
//             sprintf(name_2, "ВКЛ");
//             Send_BS_UserData(name_1, name_2);
//             WIFIinit(AccessPoint);
//             vTaskDelay(500 / portTICK_PERIOD_MS);
//             HTTPinit(); // HTTP server initialisation
//         }
//         SaveConfig();
//         break;
//     default:
//         break;
//     }
// }
// Button 5 Handling (-)
// void btn5Click()
// {
//     // Hour --
//     if (menu == IDLE)
//     {
//         int hour = Clock.hour;
//         hour--;
//         if (hour < 0)
//             hour = 23;
//         Clock.hour = hour;
//         RTC.setTime(Clock);
//         Serial.printf("Hour: %d \n\r", Clock.hour);
//         Send_GPSdata();
//     }
// }

// void configure()
// {
//     unsigned int value = analogRead(KBD_PIN);
//     Serial.println(value);
//     vTaskDelay(250 / portTICK_PERIOD_MS);
// }